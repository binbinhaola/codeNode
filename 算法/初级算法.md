## 数组

### 删除排序数组中的重复项

**给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。**

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。

将最终结果插入 nums 的前 k 个位置后返回 k 。

不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

判题标准:

系统会用下面的代码来测试你的题解:

```java
`int[] nums = [...]; // 输入数组`
`int[] expectedNums = [...]; // 长度正确的期望答案`

`int k = removeDuplicates(nums); // 调用`

`assert k == expectedNums.length;`
`for (int i = 0; i < k; i++) {`
    `assert nums[i] == expectedNums[i];`
`}`
```

解题思路：

​	使用两个指针，一个指向数组首位，一个用于遍历数组。当两指针所指元素相同时，将第二个指针后移，继续遍历，如不同则将第一个指针所指元素的后一位替换为第二个指针所对应的元素，再将两指针后移（为节省内存，当两指针相邻时，不需要进行替换操作）



### 最大字数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

1、确定子问题，保证子问题无后有效性(既当前子问题结果确认后，后续问题的计算不会印象到当前子问题的结果，就为无后有效性)

2、既子问题可为，以nums[i]为结尾的子数组的最大值为多少？

3、以nums[i]结尾的子数组的最大值为，nums[i]+(nums[i-1]的最大值)

4、当nums[i-1]<0时nums[i]结尾子数组的最大值为自身。

5、将所有以nums[i]结尾的子数组的最大值求出，再通过math.max()，计算出最大的子数组和即可



### 两个数组的交集

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

示例 1：

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

示例 2:

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

**无序数组**

1、使用hashmap获取较短数组中的值作key，次数做值

2、遍历另一数组，用重复值将值加入到新建数组中，并将此数字的值减1，为0则剔除出map

3、返回新建数组。



**有序数组**

1、新增两个指针指向两个数组

2、比较两数组值，小的指针右移，值一样将该值加入到新数组中，并将两指针都右移

3、返回新建数组



###  买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 

示例 1：

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

示例 2：

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

使用动态规划，将卖出的天数设置为i，即求出i天之前的买入最低点，然后求出最大的高低差即可。
